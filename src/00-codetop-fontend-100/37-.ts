// @ts-nocheck
/**
 * 题目名称：
 * leetcode 题目: 
 * leetcode 题解: 
 * 牛客网 题目: 
 * 牛客网 题解: 
 */

/**
 * 解法一：深度优先(递归)
 * 思路：
 * （1）当我们遇到矩阵的某个元素为1时，首先将其置为了0
 * （2）然后查看与它相邻的上下左右四个方向，如果这四个方向相邻元素为1，则进入该元素
 * （3）进入该元素之后我们发现又回到了刚刚的子问题，又是把这一片相邻区域的 1 全部置为 0 ，因此可以用递归实现。
 * 时间复杂度：O(nm)，其中m、n为矩阵的长和宽，需要遍历整个矩阵，每次dfs搜索需要经过每个值为1的元素，
 *          但是最坏情况下也只是将整个矩阵变成0，因此相当于最坏遍历矩阵2次
 * 空间复杂度：0(nm)，最坏情况下整个矩阵都是1，递归栈深度为
 */
function numIslands(grid: string[][]): number {
    
};